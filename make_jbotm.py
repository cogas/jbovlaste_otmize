# -*- coding: utf-8 -*-

import sys, json, zipfile
from jbovlaste_xmltojson import make_dict_from_xml, save_json
from collections import OrderedDict as Odict
from ponjo_tweak import goodnotes, sortcontents, integrate_gloss, delete_emptynotes, delete_dollar
import otmjson as otm

def make_content (valsi, opt, title):
    if not isinstance(valsi[opt], list):
        optlist = [valsi[opt]]
    else:
        optlist = valsi[opt]
    options = []
    if opt == "rafsi":
        options = optlist
        return otm.content(title, "   ".join(options))
    else:
        for _od in optlist:
            word = _od["@word"]
            if "@sense" in _od.keys():
                word += "; {}".format(_od["@sense"])
            if opt == "keyword":
                word = "[{}]: {}".format(_od["@place"], word)
            options.append(word)
    return otm.content(title, ", ".join(options))

def make_contents(valsi):
    contents = []
    if "notes" in valsi.keys():
        contents.append(otm.content("notes", valsi["notes"]))
    for option in [("glossword", "gloss"), ("keyword", "keyword"), ("rafsi", "rafsi")]:
        if option[0] in valsi.keys():
            contents.append(make_content(valsi, *option))
    contents.append(otm.content("username", valsi["user"]["username"]))
    return contents

def make_otmword(valsi):
    try:
        entry = otm.Entry(valsi["@word"], int(valsi["definitionid"]))
    except:
        print(valsi["@word"])
    selmaho = ": " + valsi["selmaho"] if "selmaho" in valsi.keys() else ""
    translation = otm.translation(valsi["@type"]+selmaho, [valsi["definition"]])
    translations = [translation]
    tags = []
    if "@unofficial" in valsi.keys():
        tags.append("unofficial")
    contents = make_contents(valsi)
    variations = []
    relations = []
    return Odict([("entry", entry), ("translations", translations), ("tags", tags),
                    ("contents", contents), ("variations", variations), ("relations", relations)])

def make_otmjson(rawdict, filename, lang):
    _vlaste = []
    for valsi in rawdict:
        _vla = make_otmword(valsi)
        if lang == "jpn":
            _vla = delete_dollar(delete_emptynotes(sortcontents(integrate_gloss(goodnotes(_vla)))))
        _vlaste.append(_vla)

    _langdata = {"from":"jbo", "to": lang}
    _j = Odict([("words", _vlaste), ("zpdic", {"alphabetOrder":"abcdefgijklmnoprstuvwxyz'"}),
                ("lang", _langdata)])

    otmjson = json.dumps(_j, indent=2, ensure_ascii=False)
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(otmjson)
        print("Written to {}.".format(filename))

# ------------------------------------------------------------------------

lang_list = ["all", "eng", "jpn", "jbo", "epo"]

def parse_arg():
    if len(sys.argv) == 1 :
        raise RuntimeError("No command line variables. Specify a language.")
    if len(sys.argv) >= 3 and sys.argv[2] == "--zip":
        zippable = True
    else:
        zippable = False
    langs = sys.argv[1].split('/')
    if all(lang in lang_list for lang in langs):
        return langs, zippable
    else:
        raise RuntimeError("Invalid. Available: {}".format(", ".join(lang_list)))

def load_rawdict(lang):
    filename = 'json/jbo-{}.json'.format(lang)
    try:
        with open(filename, encoding='utf-8') as f:
            rawdict = json.loads(f.read())
        print("Loaded {}".format(filename))
    except:
        print("Couldn't find '{}'. Generated by xmltojson...".format(filename))
        rawdict, _ = make_dict_from_xml(lang)
        print("OK, loaded.")
        save_json(rawdict, lang)
    return rawdict

def router(langs):
    filename_temp = 'otm-json/jbo-{}_otm.json'
    if 'all' in langs:
        running = lang_list[1:]
    else:
        running = langs
    for lang in running:
        make_otmjson(load_rawdict(lang), filename_temp.format(lang), lang)

def zip_otms(langs):
    filename_temp = 'otm-json/jbo-{}_otm.json'
    if 'all' in langs:
        langs = lang_list[1:]
    zip_path = 'zip/{}-otmjson.zip'.format("-".join(langs))
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        for lang in langs:
            zf.write(filename_temp.format(lang))
        print("OK, zipped. {}".format(zip_path))

if __name__ == '__main__':
    langs, zippable = parse_arg()
    router(langs)
    if zippable:
        zip_otms(langs)
